# ðŸ›‘ Avoid Over-Engineering: Implementation Guide

> **"The goal is business value, not technical perfection."** â€” Greg Young

This document serves as a **mandatory instruction set** for all implementation tasks. It defines the "Happy Path" philosophy, the approved technology stack, and strict anti-patterns to prevent complexity creep.

---

## 1. Core Philosophy: "Humans as Services"

**Principle:** Do not write code for the 1% of edge cases.
**Action:** If the system encounters a state outside the "Happy Path" (60-80% of traffic), **STOP** and **ESCALATE** to the user (Human-in-the-Loop).

- **âŒ Anti-Pattern:** Building complex automated recovery for rare data corruption or ambiguous inputs.
- **âœ… Pattern:** Return a clear error or ask the user: *"I found an anomaly. How should I proceed?"*
- **Why:** Code that doesn't exist has 0 bugs and 0 maintenance cost.

---

## 2. The "No Custom Logic" Rule

We use battle-tested, industry-standard libraries. **Do not reinvent the wheel.**

### **2.1 Core Runtime & Protocol**

| Capability | Library / Tool | Strict Usage Rule |
|------------|----------------|-------------------|
| **Language** | Python | `3.12+`. Use `pydantic`, `asyncio`, `typing` heavily. |
| **Protocol** | KERI (`keripy`) | Use `keri.core`, `keri.app`, `keri.db`. Do NOT roll your own crypto or event logs. |
| **Transport**| HTTP/TCP | Use `aiohttp` or `fastapi` for transport. Keep KERI logic transport-agnostic. |

### **2.2 Infrastructure (External)**

| Capability | Technology | Role | Strict Usage Rule |
|------------|------------|------|-------------------|
| **Gateway** | **Kong** (DB-less) | Ingress | Handles rate limiting, routing, and termination. Do NOT implement these in Python. |
| **Auth** | **KERI** | Identity | Use KERI AIDs for authentication. Do NOT build user tables or password hashing. |
| **Persistence** | **LMDB** | Data Layer | KERI's native fast KV store. Do NOT build custom ORMs or use SQL unless specified. |

### **2.3 Business Logic (Python)**

| Capability | Library | Strict Usage Rule |
|------------|---------|-------------------|
| **Resilience** | `tenacity` | Use for **ALL** retries, circuit breakers, timeouts. No `while` loop retries. |
| **Validation** | `pydantic` | Use Pydantic models for everything. No `if x == ""` checks. |
| **Config** | `pydantic-settings` | Use for **ALL** config loading/env binding. No `os.getenv`. |
| **CLI** | `typer` / `click` | Use for **ALL** commands/flags. No `argparse`. |
| **Logging** | `loguru` / `structlog` | Use structured logging only. No `print`. |
| **Testing** | `pytest` | Use fixtures and `assert`. No `unittest.TestCase`. |

---

## 3. Implementation Directives

### 3.1 "Brownfield" Strategy (Even in Greenfield)
- **Assume Data Exists:** Don't build for hypothetical future needs. Build for the data/requirements we have *right now*.
- **YAGNI (You Ain't Gonna Need It):** If a feature isn't required for the *immediate* task, do not build it.
- **Zero Backwards Compatibility (Pre-Launch Project):** We have **ZERO users**. Breaking changes are not only acceptable, they are **required** to maintain codebase quality. **Do NOT:**
  - Leave deprecated stubs "for compatibility"
  - Maintain old interfaces alongside new ones
  - Keep dead code "just in case"
  - **DO:** Delete old code, rename interfaces, refactor aggressively. Clean breaks are fast breaks.

### 3.2 File Modification Over Creation (Complexity Minimization)

**Core Principle:** Extend, refactor, modify, or rename existing files instead of creating new ones. Every new file is a new maintenance burden.

**âœ… Preferred Actions (in order):**
1. **Modify existing file** - Add/update functions in place
2. **Refactor existing file** - Rename, restructure, improve clarity
3. **Move code between files** - Consolidate related logic
4. **Delete dead code** - Remove unused functions, structs, files
5. **Create new file** - ONLY when existing files become unmanageably large (>1000 lines) or violate separation of concerns

**âŒ Anti-Patterns:**
- Creating `utils_v2.py` instead of refactoring `utils.py`
- Creating `new_event.py` instead of updating `event.py`
- Leaving `deprecated_*.py` files in the codebase

**Why This Matters:**
- Every file = cognitive load ("Where does this function live?")
- Every file = test coverage maintenance
- Fewer files = easier grep/search = faster development

### 3.3 The "Excel Test"
- **Question:** "Could a human do this in Excel?"
- **If Yes:** The software should be as simple as that Excel formula.
- **If No:** Is it because of volume? (Automate). Is it because of complexity? (Ask: Should we automate this, or just route to a human?)

### 3.4 "Throwing [__] at the Wall"
- **Speed over Perfection:** Get the "Walking Skeleton" running immediately.
- **Feedback Loop:** It is better to ship a feature that does 80% of the job today than 100% next month.
- **Breaking Changes Are Free:** Pre-launch = zero migration cost. Make aggressive changes now while we can.

---

## 4. Architectural Boundaries

- **Transport Isolation:** `aiohttp`/`fastapi` is allowed **ONLY** in `src/transport` or `src/api`. Business logic (`src/keri/app`) must be transport-agnostic.
- **Clock Discipline:** Use a generic `Clock` protocol. Never use `datetime.now()` directly in business logic.

---

## 5. Checklist for New Code

Before writing a single line of code, verify:
1. [ ] **File Check:** Can I modify an existing file instead of creating a new one?
2. [ ] **Deletion Check:** Can I delete dead code before adding new code?
3. [ ] **Library Check:** Am I using `tenacity`, `pydantic`, `pydantic-settings`, etc.?
4. [ ] **Complexity Check:** Am I handling a 1% edge case? (If yes -> Stop, escalate to user).
5. [ ] **YAGNI Check:** Is this feature needed *today*?
6. [ ] **Breaking Change Check:** Am I avoiding breaking changes for non-existent users? (If yes -> Stop, break the API, it's free)

---

**"Code is a liability, not an asset. The best code is no code."**
