---
description: Resilience standards: Retries, circuit breakers, and fault tolerance
globs: ["**/*.py"]
---

## Role & Intent

Define patterns for handling failures gracefully in KERI components. Enforce "Resilience Over Everything".

## Core Principles

- **Fail Securely**: If a security check fails or data is ambiguous, STOP. Do not "fail open".
- **Retry Transient Failures**: Use `tenacity` for network operations (HTTP/TCP).
- **Circuit Breakers**: Stop hammering unresponsive Witnesses/Watchers.
- **Timeouts**: Every I/O operation MUST have a timeout.
- **Graceful Degradation**: If one Witness is down, try others. If network is down, queue locally.

## Libraries

- **`tenacity`**: For retries and call limits.
- **`asyncio`**: For timeouts (`asyncio.wait_for`).

## Patterns

### Retry Decorator

```python
import tenacity

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=2, max=10),
    retry=tenacity.retry_if_exception_type(NetworkError)
)
async def fetch_kel(url: str) -> bytes:
    ...
```

### Timeout Wrapper

```python
async def safe_fetch(url: str, timeout: float = 5.0):
    try:
        return await asyncio.wait_for(fetch(url), timeout=timeout)
    except asyncio.TimeoutError:
        logger.error(f"Timeout fetching {url}")
        raise
```

## Anti-Patterns

- **Infinite Retries**: Never use `retry` without a stop condition.
- **Blanket Except**: Never catch `Exception` pass; always log or re-raise.
- **Sync I/O**: Do not block the event loop with synchronous network calls.
