---
description: Standards for KERI Event Processing, Stream Parsing, and CESR Transformation
globs: ["app/modules/transformation/**/*.py", "keri/core/**/*.py", "keri/app/**/*.py"]
alwaysApply: false
---

## Use when
- Implementing **stream parsers** for KERI event logs (KEL).
- Serializing/Deserializing data to/from **CESR** (Composable Event Streaming Representation).
- Managing **Event Pipelines** (Parsing → Validation → State Update).
- Handling **Attachments** (Signatures, Seals, Receipts) on events.
- Processing **TCP/UDP/HTTP** streams into structured KERI events.

## Do
- **Pipeline Architecture**:
  - Implement a **Parser-Reactor** pattern: One component parses the raw stream, another reacts to the events.
  - Use **Generators/Coroutines** for stream processing to handle fragmented packets efficiently.
  - Separate **Semantics** (Logic) from **Syntax** (Serialization).
- **CESR Transformation**:
  - Use the `keripy` Core Library primitives (`Matter`, `Diger`, `Verfer`, `Sigmer`) for strict type conversion.
  - Prioritize **Zero-Copy** parsing where possible for performance.
  - Validate **Version Strings** (`v` field) immediately upon detection.
- **State Management**:
  - Ensure **First-Seen** policy is enforced *before* processing content logic.
  - Use atomic updates for KEL appends to prevent inconsistent state (e.g., using `LMDB` or file locks).
- **Security**:
  - Verify **Signatures** immediately after parsing. Drop invalid events early.
  - Enforce **Sequence Number** monotonicity and hash linking.
  - Limit buffer sizes for stream parsers to prevent DoS (e.g., max message size).

## Don't
- **Anti-Patterns**:
  - Don't use generic JSON parsers for CESR-native streams (strict ordering required).
  - Don't mix Transport logic with Event Processing logic.
  - Don't buffer unbounded data waiting for a complete event (use fixed-size windows or stateful parsers).
  - Don't assume events arrive in order; buffer out-of-order events or request resends (but respect First-Seen).
- **Dependencies**:
  - Avoid heavy frameworks (e.g., Celery) for core event loop processing; use `asyncio`.
  - Don't rely on external databases for *verifying* event structure (verification should be self-contained).

## Notes / Examples
- **Flow**: Raw Bytes → CESR Parser → Message Object → Signature Verifier → KEL Appender → reactor/callback.
- **Components**:
  - `Parser`: Stateful stream processor (yields events).
  - `Kever`: Key Event Verifier (manages state).
  - `Hab`: Habitat (Environment/Context for the Controller).
- **CESR**:
  - "Composable Event Streaming Representation": Compact, text-safe, concatenable.
  - Everything is a "primitive" with a derivation code (e.g., `E` for Blake3-256).
